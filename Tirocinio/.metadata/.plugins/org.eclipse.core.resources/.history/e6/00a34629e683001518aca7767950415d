
package it.sp4te.css.agents;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

import it.sp4te.css.detection.Detector;
import it.sp4te.css.signalprocessing.Utils;

public class FusionCenter {

//Mappa snr->lista di utenti che dichiarano la presenza del PU di cardinalità pari ad ogni prova
HashMap<Double,ArrayList<ArrayList<String>>>  snrToPresenceUsers;
//Mappa snr->lista di utenti che dichiarano l'assenza del PU di cardinalità pari ad ogni prova
HashMap<Double,ArrayList<ArrayList<String>>> snrToAbsenceUsers;
//Mappa idUtente->reputazione
HashMap<String,Double> userReputation;


  public FusionCenter(){
	 double threshold=0.5;
	 snrToPresenceUsers= new HashMap<Double,ArrayList<ArrayList<String>>>();
	 snrToAbsenceUsers= new HashMap<Double,ArrayList<ArrayList<String>>>();
	 userReputation= new HashMap<String,Double>();
  }
	/**
	 * Questo metodo prende in input una mappa, contenente per ogni utente secondario (chiave) una lista di decisioni binarie calcolate
	 * per ogni SNR su un numero di prove P. Per ogni SNR prende le decisioni degli utenti secondari, li inserisce in un vettore e richiama il metodo
	 * di detection secondo la tecnica AND. Ritornerà la percentuale di Detection da parte Fusion Center
	 * @param inf Estremo inferiore dell'SNR
	 * @param sup Estremo superiore di SNR
	 * @param userToBinaryDecision Mappa che ha come chiave il nome dell'uente primario. Come valore ha una lista di liste: per ogni SNR ha una lista
	 * di lunghezza pari al numero di prove contenente la decisione binaria sulla presenza o assenza dell'utente primario da parte dell'utente secondario
	 * @return La percentuale di Detection da parte del Fusion Center dopo il metodo di fusione AND**/

	public  ArrayList<Double> andDecision(int inf,int sup,HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision){
		ArrayList<Double> EnergyDetection = new  ArrayList<Double>();

		for(int i=0;i<(sup-inf);i++){
			ArrayList<ArrayList<Integer>> decisions=new ArrayList<ArrayList<Integer>>();
			for(String SU: userToBinaryDecision.keySet()){
				ArrayList<Integer>snrDecisionVector= userToBinaryDecision.get(SU).get(i);
				decisions.add(snrDecisionVector);}

			EnergyDetection.add(Detector.andFusionDetection(decisions));
		}
		return EnergyDetection;
	}


	/**
	 * Questo metodo prende in input una mappa, contenente per ogni utente secondario (chiave) una lista di decisioni binarie calcolate
	 * per ogni SNR su un numero di prove P. Per ogni SNR prende le decisioni degli utenti secondari, li inserisce in un vettore e richiama il metodo
	 * di detection secondo la tecnica OR. Ritornerà la percentuale di Detection da parte Fusion Center
	 * @param inf Estremo inferiore dell'SNR
	 * @param sup Estremo superiore di SNR
	 * @param userToBinaryDecision Mappa che ha come chiave il nome dell'uente primario. Come valore ha una lista di liste: per ogni SNR ha una lista
	 * di lunghezza pari al numero di prove contenente la decisione binaria sulla presenza o assenza dell'utente primario da parte dell'utente secondario
	 * @return La percentuale di Detection da parte del Fusion Center dopo il metodo di fusione OR**/

	public  ArrayList<Double> orDecision(int inf,int sup,HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision){
		ArrayList<Double> EnergyDetection = new  ArrayList<Double>();

		for(int i=0;i<(sup-inf);i++){
			ArrayList<ArrayList<Integer>> decisions=new ArrayList<ArrayList<Integer>>();
			for(String SU: userToBinaryDecision.keySet()){
				ArrayList<Integer>snrDecisionVector= userToBinaryDecision.get(SU).get(i);
				decisions.add(snrDecisionVector);}

			EnergyDetection.add(Detector.orFusionDetection(decisions));
		}
		return EnergyDetection;
	}


	/**
	 * Questo metodo prende in input una mappa, contenente per ogni utente secondario (chiave) una lista di decisioni binarie calcolate
	 * per ogni SNR su un numero di prove P. Per ogni SNR prende le decisioni degli utenti secondari, li inserisce in un vettore e richiama il metodo
	 * di detection secondo la tecnica MAJORITY. Ritornerà la percentuale di Detection da parte Fusion Center
	 * @param inf Estremo inferiore dell'SNR
	 * @param sup Estremo superiore di SNR
	 * @param userToBinaryDecision Mappa che ha come chiave il nome dell'uente primario. Come valore ha una lista di liste: per ogni SNR ha una lista
	 * di lunghezza pari al numero di prove contenente la decisione binaria sulla presenza o assenza dell'utente primario da parte dell'utente secondario
	 * @return La percentuale di Detection da parte del Fusion Center dopo il metodo di fusione MAJORITY**/

	public  ArrayList<Double> majorityDecision(int inf,int sup,HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision){
		
		ArrayList<Double> EnergyDetection = new  ArrayList<Double>();

		for(int i=0;i<(sup-inf);i++){
			ArrayList<ArrayList<Integer>> decisions=new ArrayList<ArrayList<Integer>>();
			for(String SU: userToBinaryDecision.keySet()){
				ArrayList<Integer>snrDecisionVector= userToBinaryDecision.get(SU).get(i);
				decisions.add(snrDecisionVector);}

			EnergyDetection.add(Detector.majorityFusionDetection(decisions));
		}
		return EnergyDetection;
	}
	
	public  ArrayList<Double> reputationBasedDecision(int inf,int sup,HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision,int attempts){
		HashMap<Double,Double> reputationBasedDetection=new HashMap<Double,Double>();
		//creo due mappe snr->lista di utenti che dichiarano la presenza/assenza del PU di cardinalità pari ad ogni prova
		createSnrToUsers(inf,sup,userToBinaryDecision,attempts);
		for(Double snr: this.snrToPresenceUsers.keySet()){
			//System.out.println("SNR: " +snr+" ---------------------------------------------------------------------");
			ArrayList<Integer> globalDecisions= new ArrayList<Integer>();
			//Inizializzo la reputazione degli utenti
			inizializeReputation(userToBinaryDecision);
			System.out.println("-----------------------SNR: "+snr+" ---------------------------------");
			for(int attempt=0;attempt<this.snrToPresenceUsers.get(snr).size();attempt++){
				HashMap<String,Integer> binaryDecisions=computeUserToDecision(this.snrToPresenceUsers.get(snr).get(attempt),
						this.snrToAbsenceUsers.get(snr).get(attempt));
			Integer globalDecision=computeGlobalDecision(binaryDecisions);
			
			globalDecisions.add(globalDecision);
			updateReputation(globalDecision,this.snrToPresenceUsers.get(snr).get(attempt),this.snrToAbsenceUsers.get(snr).get(attempt));
			}
			reputationBasedDetection.put(snr,Detector.reputationBasedDetection(globalDecisions));
		}
		return Utils.orderSignal(reputationBasedDetection);
		
	}
	
	
	public void updateReputation(int globalDecision,ArrayList<String>  presenceSU,ArrayList<String>  absenceSU){
		for(int i=0;i<presenceSU.size();i++){
			double newReputation=this.userReputation.get(presenceSU.get(i))+ Math.pow(-1,(1+globalDecision));
			//System.out.println("User: "+presenceSU.get(i)+" "+"OldReputation: "+this.userReputation.get(presenceSU.get(i))
			//+" "+"NewReputation: "+newReputation);
			this.userReputation.replace(presenceSU.get(i),newReputation);
		}
		
		for(int i=0;i<absenceSU.size();i++){
			double newReputation=this.userReputation.get(absenceSU.get(i))+ Math.pow(-1,(0+globalDecision));
			//System.out.println("User: "+absenceSU.get(i)+" "+"OldReputation: "+this.userReputation.get(absenceSU.get(i))
			//+" "+"NewReputation: "+newReputation);
			this.userReputation.replace(absenceSU.get(i),newReputation);
		}
		//System.out.println("-------");
	}
	
	public void createSnrToUsers(int inf,int sup,HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision,int attempts){
		for(int i=0;i<(sup-inf);i++){
			ArrayList<ArrayList<String>> listOfPresenceUser =new ArrayList<ArrayList<String>>();	
			ArrayList<ArrayList<String>> listOfAbsenceUser=new ArrayList<ArrayList<String>>();	
			for(int j=0;j<attempts;j++){
				ArrayList<String> presenceUser =new ArrayList<String>();	
				ArrayList<String> nonPresenceUser=new ArrayList<String>();	
			for(String SU: userToBinaryDecision.keySet()){
				if(userToBinaryDecision.get(SU).get(i).get(j)==0){
					nonPresenceUser.add(SU);}
				else{
					presenceUser.add(SU);}
			}
			listOfPresenceUser.add(presenceUser);
			listOfAbsenceUser.add(nonPresenceUser);
		}

		this.snrToPresenceUsers.put((double)(inf-sup)+i,listOfPresenceUser );
		this.snrToAbsenceUsers.put((double)(inf-sup)+i, listOfAbsenceUser);
		
		
		}
	}
	
	public void inizializeReputation(HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision){
		for(String SU: userToBinaryDecision.keySet()){
			this.userReputation.put(SU, 5.0);
		}
		
	}
	
	/**Ritorna una mappa utente->Decisione**/
	public HashMap<String,Integer> computeUserToDecision(ArrayList<String> presenceUsers,ArrayList<String> absenceUsers){
		HashMap<String,Integer> binaryDecisions= new HashMap<String,Integer>();
		for(int SU=0;SU<presenceUsers.size();SU++){
			double reputation = userReputation.get(presenceUsers.get(SU));
			//System.out.println("User: "+presenceSU.get(i)+" "+"OldReputation: "+this.userReputation.get(presenceSU.get(i))

			System.out.println("presence: "+presenceUsers.get(SU)+" Reputation: "+reputation);
			if(reputation>=1){
				binaryDecisions.put(presenceUsers.get(SU), 1);
			}}
		for(int SU2=0;SU2<absenceUsers.size();SU2++){
			double reputation = userReputation.get(absenceUsers.get(SU2));
			System.out.println("absence: "+absenceUsers.get(SU2) +" Reputation: "+reputation);
			if(reputation>=1){
				binaryDecisions.put(absenceUsers.get(SU2),0);
				}
		}
		System.out.println("-----------");
		return binaryDecisions;
	}
	
	public int computeGlobalDecision(HashMap<String,Integer> binaryDecisions){
		int globalDecision;
		double cont=0;
		double maxReputation= getMaxReputation(binaryDecisions.keySet());
		//sommatoria w'(j)
		double totalPartialWeight= getPartialTotalWeigth(binaryDecisions.keySet(),maxReputation);
		for(String SU: binaryDecisions.keySet()){
			System.out.println("User: "+binaryDecisions.get(SU)+" Weight: "+ computeWeight(SU,totalPartialWeight,maxReputation)
			+"Reputation: "+userReputation.get(binaryDecisions.get(SU)));
			cont=cont+( binaryDecisions.get(SU)*computeWeight(SU,totalPartialWeight,maxReputation));
			//System.out.println("Cont: "+cont);
		}
		//System.out.println("Cont: "+cont);
		//System.out.println("-----");
		if(cont>=0.5){globalDecision=1;}
		else{globalDecision=0;}
		return globalDecision;
	}
	
	public double computeWeight(String SU,double totalPartialWeight,double maxReputation){
		double weight= (userReputation.get(SU)/maxReputation)/totalPartialWeight;
		//System.out.println("User: " + SU+" "+"Weight: "+weight);
		//System.out.println("-----");
		return weight;
		
	}
	
	public double getPartialTotalWeigth(Set<String> listSU,double maxReputation){
		double  totalPartialWeigth=0.0;
		for(String su: listSU){
			 totalPartialWeigth= totalPartialWeigth+(userReputation.get(su)/maxReputation); 
		}
		return totalPartialWeigth;
	}
	public double getMaxReputation(Set<String> listSU){
		double maxReputation=0.0;
		for(String su: listSU){
			if(userReputation.get(su)>maxReputation){
				maxReputation=userReputation.get(su);
			}
		}
		return maxReputation;
	}

}

