package it.sp4te.css.agents;

import java.util.ArrayList;
import java.util.HashMap;

import it.sp4te.css.detection.Detector;
import it.sp4te.css.model.Signal;
import it.sp4te.css.signalprocessing.Moment;
import it.sp4te.css.signalprocessing.SignalProcessor;

public abstract class SecondaryUser {

	Signal s;
	int attempts,length,inf,sup,block;
	double energy;
	ArrayList<Moment> MomentsSignal;
	ArrayList<Moment> MomentsNoise;
	
	
	/**
	 * Questo metodo inizializza i valori che saranno usati nei diversi tipi di
	 * detection.
	 * 
	 * @param s Segnale su cui effettuare la Detection
	 * @param length lunghezza del segnale
	 * @param energy Energia del segnale
	 * @param attempts Numero di prove su cui viene effettuata la simulazione
	 * @param inf Estremo inferiore di SNR su cui è stata effettuata la simulazione
	 * @param sup Estremo superiore di SNR su cui è stata effettuata la simulazione
	 * @param block Blocchi in cui dividere il segnale per l'energy Detector
	 * @see SignalProcessor#computeMoment
	 * @see SignalProcessor#computeEnergy
	 * @see SignalProcessor#computePr
	 * @see SignalProcessor#computeMediumEnergy
	 * 
	 **/


	public void listenChannel(Signal s, int length, double energy, int attempts, int inf, int sup,int block){
		//Oggetto momento nell'ipotesi Segnale più rumore
		this.MomentsSignal = SignalProcessor.computeMoment(s, length, energy, attempts, inf, sup);
		//Oggetto momento nell'ipotesi di solo Rumore
		this.MomentsNoise =SignalProcessor.computeMoment(null, length, energy, attempts, inf, sup);
		//Setto i parametri
		this.s=s;
		this.length=length;
		this.energy=energy;
		this.attempts=attempts;
		this.inf=inf;
		this.sup=sup;
		this.block=block;

	}
	/**
	 * Metodo per lo Spectrum Senging dell'energy Detector. Il confronto viene fatto tra la soglia e un vettore di energie ottenuto
	 * dividendo il segnale in M blocchi da N campioni e facendo la media delle energie.
	 * 
	 * @param pfa Probabilità di falso allarme
	 * @return Array con le percentuali di detection ordinate per SNR
	 * @throws Exception Pfa deve essere scelto in modo che 1-2pfa sia compreso tra -1 e 1
	 * @see Detector#energyDetection
	 * @see SignalProcessor#orderSignal
	 * @see  SignalProcessor#computeEnergyDetectorThreshold
	 **/

	public ArrayList<Double> spectrumSensingBlockEnergyDetector(Double pfa) throws Exception{
		HashMap<Double, Double> EnergyDetection = new HashMap<Double, Double>();
		ArrayList<ArrayList<Double>> MediumNoiseEnergy=SignalProcessor.computeMediumEnergy(null, length, energy, attempts, inf, sup, block);
		ArrayList<ArrayList<Double>> MediumSignalEnergy;
		if(s!=null){
			MediumSignalEnergy=SignalProcessor.computeMediumEnergy(s, length, energy, attempts, inf, sup, block);
		}
		else{MediumSignalEnergy=MediumNoiseEnergy;}
		
		for (int i = 0; i < MediumSignalEnergy.size(); i++) {
			Double ED = Detector.energyDetection(
					SignalProcessor.computeEnergyDetectorThreshold(pfa, MediumNoiseEnergy.get(i)), MediumSignalEnergy.get(i));
			EnergyDetection.put(this.MomentsSignal.get(i).getSnr(), ED);
		}

		return SignalProcessor.orderSignal(EnergyDetection);
	}
	
	
	
	/**
	 * Metodo per lo Spectrum Senging dell'energy Detector effettuato senza dividere il segnale in blocchi,
	 * calcolando l'energia a partire dai momenti del secondo e quarto ordine. 
	 * 
	 * @param pfa Probabilità di falso allarme
	 * @return Array con le percentuali di detection ordinate per SNR
	 * @throws Exception  Pfa deve essere scelto in modo che 1-2pfa sia compreso tra -1 e 1
	 * @see Detector#energyDetection
	 * @see SignalProcessor#orderSignal
	 * @see  SignalProcessor#computeEnergyDetectorThreshold
	 **/
	
	public ArrayList<Double> spectrumSensingMomentEnergyDetector(double pfa) throws Exception {
		HashMap<Double, Double> EnergyDetection = new HashMap<Double, Double>();
		ArrayList<ArrayList<Double>> MomentNoiseEnergy = SignalProcessor.computeMomentEnergy(MomentsNoise);
		ArrayList<ArrayList<Double>> MomentSignalEnergy;
		if(s!=null){MomentSignalEnergy = SignalProcessor.computeMomentEnergy(MomentsSignal);}
		else{MomentSignalEnergy=MomentNoiseEnergy;}
		
		for (int i = 0; i < MomentSignalEnergy.size(); i++) {
			Double ED = Detector.energyDetection(
					SignalProcessor.computeEnergyDetectorThreshold(pfa, MomentNoiseEnergy.get(i)), MomentSignalEnergy.get(i));
			EnergyDetection.put(this.MomentsSignal.get(i).getSnr(), ED);
		}

		return SignalProcessor.orderSignal(EnergyDetection);
	}

	/**
	 * Metodo per lo Spectrum sensing del metodo proposto. Il procedimento è simile a quello dell'energy Detector ma con
	 * la differenza che utilizza gli oggetti PR al posto dei momenti del secondo e quarto ordine.
	 * 
	 * @param pfa Probabilità di falso allarme
	 * @return Array con le percentuali di detection ordinate per SNR
	 * @throws Exception Pfa deve essere scelto in modo che 1-2pfa sia compreso tra -1 e 1
	 * @see Detector#proposedMethodDetection
	 * @see SignalProcessor#orderSignal
	 * @see SignalProcessor#computeProposedThreshold
	 * 
	 **/

	public ArrayList<Double> spectrumSensingProposedDetector(Double pfa) throws Exception {
		HashMap<Double, Double> ProposedDetection = new HashMap<Double, Double>();
		ArrayList<ArrayList<Double>> PrNoise = SignalProcessor.computePr(MomentsNoise);
		ArrayList<ArrayList<Double>> PrSignal;
		if(s!=null){PrSignal = SignalProcessor.computePr(MomentsSignal);}
		else{PrSignal=PrNoise;}
		
		for (int i = 0; i < PrSignal.size(); i++) {
			Double PD = Detector.proposedMethodDetection(SignalProcessor.computeProposedThreshold(pfa, PrNoise.get(i)),
					PrSignal.get(i));
			ProposedDetection.put(this.MomentsSignal.get(i).getSnr(), PD);
		}
		return SignalProcessor.orderSignal(ProposedDetection);
	}

	
	/**Questo metodo rappresenta l'energy Detector tradizionale. Effettua il calcolo dell'energia del solo rumore su cui
	 * calcola la soglia. Successivamente calcola l'energia del segnale+rumore ed effettua il confronto con la soglia
	 * calcolata.
	 * @param pfa Probabilità di falso allarme
	 * @return Ritorna la percentuale di Detection calcolata sulle energie senza operazioni intermedie
	 * @throws Exception **/
	
	public ArrayList<Double> spectrumSensingTraditionalEnergyDetector(double pfa) throws Exception {
		HashMap<Double, Double> EnergyDetection = new HashMap<Double, Double>();
		ArrayList<ArrayList<Double>> VectorNoiseEnergy=SignalProcessor.computeVectorEnergy(null, length, energy, attempts, inf, sup);	

		ArrayList<ArrayList<Double>> VectorSignalEnergy;
		if(s!=null){
	    VectorSignalEnergy=SignalProcessor.computeVectorEnergy(s, length, energy, attempts, inf, sup);
		}	
		else{VectorSignalEnergy=VectorNoiseEnergy;}
		
		for (int i = 0; i < VectorSignalEnergy.size(); i++) {
			Double ED = Detector.energyDetection(
					SignalProcessor.computeEnergyDetectorThreshold(pfa, VectorNoiseEnergy.get(i)), VectorSignalEnergy.get(i));
			EnergyDetection.put(this.MomentsSignal.get(i).getSnr(), ED);
		}

		return SignalProcessor.orderSignal(EnergyDetection);
	}
	
	/**Questo metodo ritorna, per ogni valore di SNR , una lista di decisioni lunga quanto il numero di prove contenente la presenza (1) o
	 * l'assenza(0) dell'utente primario
	 * @param pfa Probabilità di falso allarme
	 * @return Una lista di liste contenente per ogni SNR, una lista decisioni binarie sulla presenza o assenza dell'utente primario di cardinalità pari al numero di prove
	 * @throws Exception **/
	
	public ArrayList<ArrayList<Integer>> computeBinaryDecision(double pfa) throws Exception{
		ArrayList<ArrayList<Integer>> decisions= new  ArrayList<ArrayList<Integer>>();
		for(int i=inf;i<sup;i++){
			
			ArrayList<ArrayList<Double>> VectorNoiseEnergy=SignalProcessor.computeVectorEnergy(null, length, energy, attempts, i, i+1);	
			double threshold=SignalProcessor.computeEnergyDetectorThreshold(pfa, VectorNoiseEnergy.get(0));
			
			ArrayList<Integer> snrDecisions= new  ArrayList<Integer>();
			ArrayList<ArrayList<Double>> EnergyVector;
			
			if(s!=null){
			EnergyVector=SignalProcessor.computeVectorEnergy(s, length,energy,attempts, i,i+1);		}	
			else{
				EnergyVector=VectorNoiseEnergy;
			}
			for(int j=0;j<EnergyVector.get(0).size();j++){
				if(EnergyVector.get(0).get(j)>threshold){
					snrDecisions.add(1);
				}
				else{snrDecisions.add(0);}
				
			}
			decisions.add(snrDecisions);
		
			
		}
		return decisions;	
		}
		
	

}
