package it.sp4te.css.signalprocessing;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

import it.sp4te.css.agents.MaliciousSecondaryUser;
import it.sp4te.css.agents.TrustedSecondaryUser;
import it.sp4te.css.model.Signal;

public class Utils {

	
	/**
	 * Metodo per ordinare una mappa in base alla chiave.
	 * In questo caso è utilizzato su una mappa che ha come chiave l'SNR e come valore la % di Detection Relativa.
	 * 
	 * @param signalmapToOrder mappa con chiave SNR e valore la relativa % di detection 
	 * @return la mappa ordinata in base all'SNR
	 **/

	public static ArrayList<Double> orderSignal(HashMap<Double, Double> signalmapToOrder) {

		ArrayList<Double> snr = new ArrayList<Double>();
		for (Double key : signalmapToOrder.keySet()) {
			snr.add(key);
		}
		Collections.sort(snr);

		ArrayList<Double> Edetection = new ArrayList<Double>();
		for (Double key : snr) {
			Edetection.add(signalmapToOrder.get(key));
		}
		return Edetection;
	}
	
	public static ArrayList<TrustedSecondaryUser> createTrustedSecondaryUsers(int number,Signal s,
			int SignalLength, double energy, int attempts, int inf, int sup,int block){
		
		ArrayList<TrustedSecondaryUser> TrustedSecondaryUsers = new ArrayList<TrustedSecondaryUser>();
		for(int i=0;i<number;i++){
			TrustedSecondaryUser TSU=new TrustedSecondaryUser();
			TSU.listenChannel(s, SignalLength, energy, attempts, inf, sup, block);
			TrustedSecondaryUsers.add(TSU);
		}
		
		return TrustedSecondaryUsers;
		
	}
	
	public static ArrayList<MaliciousSecondaryUser> createMaliciousSecondaryUsers(int number,Signal s,
			int SignalLength, double energy, int attempts, int inf, int sup,int block){
		
		ArrayList<MaliciousSecondaryUser> MaliciousSecondaryUsers = new ArrayList<MaliciousSecondaryUser>();
		for(int i=0;i<number;i++){
			MaliciousSecondaryUser MSU=new MaliciousSecondaryUser();
			MSU.listenChannel(s, SignalLength, energy, attempts, inf, sup, block);
			MaliciousSecondaryUsers.add(MSU);
		}
		
		return MaliciousSecondaryUsers;
		
	}
	
	public static HashMap<String,ArrayList<ArrayList<Integer>>> genereteBinaryDecisionVectors(
			ArrayList<TrustedSecondaryUser> TrustedSecondaryUsers,double pfa) throws Exception{
		HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision=new HashMap<String,ArrayList<ArrayList<Integer>>>();

		for(int i=0;i<TrustedSecondaryUsers.size();i++){
			userToBinaryDecision.put(TrustedSecondaryUsers.get(i).toString(), TrustedSecondaryUsers.get(i).computeBinaryDecisionVector(pfa));	
		}
		return userToBinaryDecision;
	}
	
	public static HashMap<String,ArrayList<ArrayList<Integer>>> genereteAbsenceBinaryDecisionVectors(
			ArrayList<MaliciousSecondaryUser> MaliciousSecondaryUsers,double pfa) throws Exception{
		HashMap<String,ArrayList<ArrayList<Integer>>> userToBinaryDecision=new HashMap<String,ArrayList<ArrayList<Integer>>>();

		for(int i=0;i<MaliciousSecondaryUsers.size();i++){
			userToBinaryDecision.put(MaliciousSecondaryUsers.get(i).toString(), MaliciousSecondaryUsers.get(i).computeAbsenceBinaryDecisionVector());	
		}
		return userToBinaryDecision;
	}
}
